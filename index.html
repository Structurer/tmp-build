<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>网格布局</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 布局参数 - 使用固定值作为默认值（800像素以上） */
        :root {
            /* 间距参数 */
            --column-gap: 5px; /* 基本列间间距 */
            --column-gap-1-2: 5px; /* 第1列和第2列之间的间距 */
            --column-gap-2-3: 5px; /* 第2列和第3列之间的间距 */
            --column-gap-3-4: 5px; /* 第3列和第4列之间的间距 */
            --column-gap-4-5: 20px; /* 第4列和第5列之间的间距 */
            --column-gap-5-6: 5px; /* 第5列和第6列之间的间距 */
            --column-gap-6-7: 5px; /* 第6列和第7列之间的间距 */
            --column-gap-7-8: 5px; /* 第7列和第8列之间的间距 */
            --column-gap-8-9: 20px; /* 第8列和第9列之间的间距 */
            --column-gap-9-10: 5px; /* 第9列和第10列之间的间距 */
            --column-gap-10-11: 5px; /* 第10列和第11列之间的间距 */
            --column-gap-11-12: 5px; /* 第11列和第12列之间的间距 */

            --row-gap: 5px; /* 基本行间间距 */
            --row-gap-1-2: 20px; /* 第1行和第2行之间的间距 */
            --row-gap-2-3: 20px; /* 第2行和第3行之间的间距 */
            --row-gap-3-4: 5px; /* 第3行和第4行之间的间距 */
            --row-gap-4-5: 5px; /* 第4行和第5行之间的间距 */
            --row-gap-5-6: 5px; /* 第5行和第6行之间的间距 */
            
            /* 卡片尺寸参数 */
            --card-width: 50px; /* 卡片的宽度 */
            --card-height: 50px; /* 卡片的高度 */
            --card-padding: 0px; /* 卡片内边距 */
        }
        
        /* 响应式设计 - 在800像素以下使用vw单位实现等比例缩放 */
        @media (max-width: 800px) {
            :root {
                /* 间距参数 - 使用vw单位，实现等比例缩放 */
                --column-gap: 0.625vw; /* 5px / 800px * 100 = 0.625vw */
                --column-gap-1-2: 0.625vw;
                --column-gap-2-3: 0.625vw;
                --column-gap-3-4: 0.625vw;
                --column-gap-4-5: 2.5vw; /* 20px / 800px * 100 = 2.5vw */
                --column-gap-5-6: 0.625vw;
                --column-gap-6-7: 0.625vw;
                --column-gap-7-8: 0.625vw;
                --column-gap-8-9: 2.5vw;
                --column-gap-9-10: 0.625vw;
                --column-gap-10-11: 0.625vw;
                --column-gap-11-12: 0.625vw;

                --row-gap: 0.625vw;
                --row-gap-1-2: 2.5vw; /* 20px / 800px * 100 = 2.5vw */
                --row-gap-2-3: 2.5vw;
                --row-gap-3-4: 0.625vw;
                --row-gap-4-5: 0.625vw;
                --row-gap-5-6: 0.625vw;
                
                /* 卡片尺寸参数 - 使用vw单位，实现等比例缩放 */
                --card-width: 6.25vw; /* 50px / 800px * 100 = 6.25vw */
                --card-height: 6.25vw; /* 50px / 800px * 100 = 6.25vw */
            }
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        /* 12列6行网格布局 */
        .grid-container {
            display: grid;
            /* 明确设置12列的结构，不会重组 */
            grid-template-columns: repeat(12, var(--card-width));
            /* 明确设置6行的结构 */
            grid-template-rows: repeat(6, var(--card-height));
            /* 设置列间距和行间距 */
            column-gap: var(--column-gap);
            row-gap: var(--row-gap);
            /* 居中显示 */
            margin: 0 auto;
            margin-bottom: 20px;
            /* 确保宽度适合内容，不会重组 */
            width: fit-content;
            /* 最小宽度为内容宽度，确保不会重组 */
            min-width: min-content;
            /* 当宽度超过容器时，显示水平滚动条 */
            overflow-x: auto;
        }
        
        /* 确保容器不会限制grid布局的宽度 */
        .container {
            /* 最大宽度为100%，允许水平滚动 */
            max-width: 100%;
            /* 当grid布局宽度超过容器时，显示水平滚动条 */
            overflow-x: auto;
        }
        
        /* 确保body不会限制容器宽度 */
        body {
            /* 允许水平滚动 */
            overflow-x: auto;
        }
        
        /* 网格项样式 */
        .grid-item {
            background-color: #f5f5f5;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            padding: var(--card-padding);
            text-align: center;
            font-weight: bold;
            color: #1976d2;
            height: var(--card-height);
            width: var(--card-width); /* 使用 --card-width 变量，确保卡片宽度和高度可以不同 */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease;
            cursor: pointer;
            box-sizing: border-box; /* 确保padding和border不影响卡片尺寸 */
        }
        
        /* 位置调整：确保每个卡片都在正确的位置 */
        /* 第一行 */
        .grid-container > div:nth-child(1) { grid-column: 1; grid-row: 1; }
        .grid-container > div:nth-child(2) { grid-column: 2; grid-row: 1; }
        .grid-container > div:nth-child(3) { grid-column: 3; grid-row: 1; }
        .grid-container > div:nth-child(4) { grid-column: 4; grid-row: 1; }
        .grid-container > div:nth-child(5) { grid-column: 5; grid-row: 1; }
        .grid-container > div:nth-child(6) { grid-column: 6; grid-row: 1; }
        .grid-container > div:nth-child(7) { grid-column: 7; grid-row: 1; }
        .grid-container > div:nth-child(8) { grid-column: 8; grid-row: 1; }
        .grid-container > div:nth-child(9) { grid-column: 9; grid-row: 1; }
        .grid-container > div:nth-child(10) { grid-column: 10; grid-row: 1; }
        .grid-container > div:nth-child(11) { grid-column: 11; grid-row: 1; }
        .grid-container > div:nth-child(12) { grid-column: 12; grid-row: 1; }
        
        /* 第二行 */
        .grid-container > div:nth-child(13) { grid-column: 1; grid-row: 2; }
        .grid-container > div:nth-child(14) { grid-column: 2; grid-row: 2; }
        .grid-container > div:nth-child(15) { grid-column: 3; grid-row: 2; }
        .grid-container > div:nth-child(16) { grid-column: 4; grid-row: 2; }
        .grid-container > div:nth-child(17) { grid-column: 5; grid-row: 2; }
        .grid-container > div:nth-child(18) { grid-column: 6; grid-row: 2; }
        .grid-container > div:nth-child(19) { grid-column: 7; grid-row: 2; }
        .grid-container > div:nth-child(20) { grid-column: 8; grid-row: 2; }
        .grid-container > div:nth-child(21) { grid-column: 9; grid-row: 2; }
        .grid-container > div:nth-child(22) { grid-column: 10; grid-row: 2; }
        .grid-container > div:nth-child(23) { grid-column: 11; grid-row: 2; }
        .grid-container > div:nth-child(24) { grid-column: 12; grid-row: 2; }
        
        /* 第三行 */
        .grid-container > div:nth-child(25) { grid-column: 1; grid-row: 3; }
        .grid-container > div:nth-child(26) { grid-column: 2; grid-row: 3; }
        .grid-container > div:nth-child(27) { grid-column: 3; grid-row: 3; }
        .grid-container > div:nth-child(28) { grid-column: 4; grid-row: 3; }
        .grid-container > div:nth-child(29) { grid-column: 5; grid-row: 3; }
        .grid-container > div:nth-child(30) { grid-column: 6; grid-row: 3; }
        .grid-container > div:nth-child(31) { grid-column: 7; grid-row: 3; }
        .grid-container > div:nth-child(32) { grid-column: 8; grid-row: 3; }
        .grid-container > div:nth-child(33) { grid-column: 9; grid-row: 3; }
        .grid-container > div:nth-child(34) { grid-column: 10; grid-row: 3; }
        .grid-container > div:nth-child(35) { grid-column: 11; grid-row: 3; }
        .grid-container > div:nth-child(36) { grid-column: 12; grid-row: 3; }
        
        /* 第四行 */
        .grid-container > div:nth-child(37) { grid-column: 1; grid-row: 4; }
        .grid-container > div:nth-child(38) { grid-column: 2; grid-row: 4; }
        .grid-container > div:nth-child(39) { grid-column: 3; grid-row: 4; }
        .grid-container > div:nth-child(40) { grid-column: 4; grid-row: 4; }
        .grid-container > div:nth-child(41) { grid-column: 5; grid-row: 4; }
        .grid-container > div:nth-child(42) { grid-column: 6; grid-row: 4; }
        .grid-container > div:nth-child(43) { grid-column: 7; grid-row: 4; }
        .grid-container > div:nth-child(44) { grid-column: 8; grid-row: 4; }
        .grid-container > div:nth-child(45) { grid-column: 9; grid-row: 4; }
        .grid-container > div:nth-child(46) { grid-column: 10; grid-row: 4; }
        .grid-container > div:nth-child(47) { grid-column: 11; grid-row: 4; }
        .grid-container > div:nth-child(48) { grid-column: 12; grid-row: 4; }
        
        /* 第五行 */
        .grid-container > div:nth-child(49) { grid-column: 1; grid-row: 5; }
        .grid-container > div:nth-child(50) { grid-column: 2; grid-row: 5; }
        .grid-container > div:nth-child(51) { grid-column: 3; grid-row: 5; }
        .grid-container > div:nth-child(52) { grid-column: 4; grid-row: 5; }
        .grid-container > div:nth-child(53) { grid-column: 5; grid-row: 5; }
        .grid-container > div:nth-child(54) { grid-column: 6; grid-row: 5; }
        .grid-container > div:nth-child(55) { grid-column: 7; grid-row: 5; }
        .grid-container > div:nth-child(56) { grid-column: 8; grid-row: 5; }
        .grid-container > div:nth-child(57) { grid-column: 9; grid-row: 5; }
        .grid-container > div:nth-child(58) { grid-column: 10; grid-row: 5; }
        .grid-container > div:nth-child(59) { grid-column: 11; grid-row: 5; }
        .grid-container > div:nth-child(60) { grid-column: 12; grid-row: 5; }
        
        /* 第六行 */
        .grid-container > div:nth-child(61) { grid-column: 1; grid-row: 6; }
        .grid-container > div:nth-child(62) { grid-column: 2; grid-row: 6; }
        .grid-container > div:nth-child(63) { grid-column: 3; grid-row: 6; }
        .grid-container > div:nth-child(64) { grid-column: 4; grid-row: 6; }
        .grid-container > div:nth-child(65) { grid-column: 5; grid-row: 6; }
        .grid-container > div:nth-child(66) { grid-column: 6; grid-row: 6; }
        .grid-container > div:nth-child(67) { grid-column: 7; grid-row: 6; }
        .grid-container > div:nth-child(68) { grid-column: 8; grid-row: 6; }
        .grid-container > div:nth-child(69) { grid-column: 9; grid-row: 6; }
        .grid-container > div:nth-child(70) { grid-column: 10; grid-row: 6; }
        .grid-container > div:nth-child(71) { grid-column: 11; grid-row: 6; }
        .grid-container > div:nth-child(72) { grid-column: 12; grid-row: 6; }
        
        .grid-item:hover {
            background-color: #e0e0e0;
        }
        
        /* 控制按钮样式 */
        .control-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .control-buttons button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .control-buttons button:hover {
            background-color: #45a049;
        }
        
        /* 游戏模式样式 */
        .game-mode {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .current-card {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
            padding: 20px;
            background-color: #e3f2fd;
            border-radius: 4px;
            border: 2px solid #2196f3;
        }
        
        /* 卡片序列容器样式 - 使用flexbox确保垂直居中 */
        .card-sequence-container {
            position: relative;
            width: calc(var(--card-width) * 5 + var(--column-gap-1-2) * 6 + var(--column-gap-1-2) * 2);
            margin: 15px auto;
            height: calc(var(--card-height) + 20px); /* 足够容纳内容和可能的滚动条空间 */
            overflow: hidden;
            display: flex;
            align-items: center;
        }

        /* 卡片序列样式 */
        .card-sequence {
            display: flex;
            overflow-x: auto;
            gap: var(--column-gap-1-2);
            padding: var(--column-gap-1-2);
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f5f5f5;
            width: 100%;
            position: relative;
            z-index: 1;
            scroll-behavior: smooth;
        }
        
        /* 卡片序列容器的边距和高度也会通过CSS变量自动响应式调整 */

        /* 完全隐藏水平滚动条但保留滚动功能 */
        .card-sequence::-webkit-scrollbar {
            height: 0;
            width: 0;
        }

        .card-sequence::-webkit-scrollbar-track {
            background: transparent;
        }

        .card-sequence::-webkit-scrollbar-thumb {
            background: transparent;
        }

        /* 对于Firefox */
        .card-sequence {
            scrollbar-width: none;
        }

        /* 高亮框样式 - 取消居中的高光圈，只保留卡片序列中的当前卡片高亮 */
        .highlight-box {
            display: none;
        }

        /* 游戏消息样式 */
        .game-message {
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #ff5722;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: relative;
            z-index: 10;
        }

        .game-message h4 {
            color: #ff5722;
            margin-bottom: 15px;
        }

        .game-message button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .game-message button:hover {
            background-color: #45a049;
        }


        
        .sequence-card {
            flex: 0 0 auto;
            width: var(--card-width);
            height: var(--card-height);
            padding: var(--card-padding);
            background-color: #f5f5f5;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            color: #1976d2;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        
        .sequence-card.completed {
            opacity: 0.5;
            background-color: #e8f5e9;
            border-color: #c8e6c9;
        }
        
        .sequence-card.current {
            /* 高亮效果，明显提示当前需要输入的卡片 */
            background-color: #ffecb3;
            border: 3px solid #ffc107;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.7);
            transform: scale(1.1);
            transition: all 0.3s ease;
        }
        
        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 14px;
        }
        
        /* 二进制编码显示样式 */
        .binary-code {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 16px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* 特殊位置的格子 */
        .top-item {
            background-color: #f5f5f5;
            border: 1px solid #ffcc80;
            color: #ef6c00;
        }
        
        .top-item:hover {
            background-color: #e0e0e0;
        }
        
        /* 2的卡片样式 */
        .two-item {
            background-color: #f5f5f5;
            border: 1px solid #e1bee7;
            color: #7b1fa2;
        }
        
        .two-item:hover {
            background-color: #e0e0e0;
        }
        
        /* 激活状态 */
        .active {
            background-color: #4caf50 !important;
            color: white !important;
        }
        
        /* 空白卡片样式 */
        .empty-card {
            background-color: transparent !important;
            border: 1px solid transparent !important;
            cursor: default !important;
        }
        
        .empty-card:hover {
            background-color: transparent !important;
        }
        
        /* 移除会改变列数的响应式断点，只保留600px时的大小调整 */
        /* 确保网格始终保持12列结构，通过水平滚动适应不同屏幕宽度 */
    </style>
</head>
<body>
    <div class="container">
        <h1>记忆训练系统</h1>
        
        <!-- 功能按钮 -->
        <div class="control-buttons">
            <button onclick="generateRandomBinary()">生成随机模式</button>
            <button onclick="toggleSuitMode()" id="suitModeButton">无花色模式</button>
            <button onclick="toggleLayoutMode()" id="layoutModeButton">默认布局</button>
            <button onclick="toggleGameMode()" id="gameModeButton">游戏模式</button>
        </div>
        
        <!-- 二进制编码显示 -->
        <div class="binary-code" id="binaryCode">生成的二进制编码: </div>
        
        <!-- 游戏模式界面 -->
        <div class="game-mode" id="gameMode" style="display: none;">
            <h3>游戏模式</h3>
            <div class="card-sequence-container">
                <div class="card-sequence" id="cardSequence">
                    <!-- 卡片序列将通过JavaScript动态生成 -->
                </div>
                <div class="highlight-box" id="highlightBox"></div>
            </div>
            <div class="game-stats">
                <div>当前进度: <span id="gameProgress">0/54</span></div>
                <div>正确次数: <span id="gameCorrect">0</span></div>
                <div>错误次数: <span id="gameWrong">0</span></div>
                <div>当前速度: <span id="gameSpeed">1.0x</span></div>
            </div>
        </div>
        
        <!-- 扑克牌编码映射（位置记忆法） -->
        <div class="grid-container">
            <!-- 第一行：大小王（第6、7格） -->
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item top-item" onclick="toggleStatus(this)">小王</div>
            <div class="grid-item top-item" onclick="toggleStatus(this)">大王</div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            
            <!-- 第二行：2的四张牌（中间四个） -->
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item two-item" onclick="toggleStatus(this)">* 2</div>
            <div class="grid-item two-item" onclick="toggleStatus(this)">* 2</div>
            <div class="grid-item two-item" onclick="toggleStatus(this)">* 2</div>
            <div class="grid-item two-item" onclick="toggleStatus(this)">* 2</div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            
            <!-- 第三行：3-5, 6-8, 9-10, J-Q-K-A -->
            <div class="grid-item" onclick="toggleStatus(this)">* 3</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 4</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 5</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 6</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 7</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 8</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 9</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 10</div>
            <div class="grid-item" onclick="toggleStatus(this)">* J</div>
            <div class="grid-item" onclick="toggleStatus(this)">* Q</div>
            <div class="grid-item" onclick="toggleStatus(this)">* K</div>
            <div class="grid-item" onclick="toggleStatus(this)">* A</div>
            
            <!-- 第四行：3-5, 6-8, 9-10, J-Q-K-A -->
            <div class="grid-item" onclick="toggleStatus(this)">* 3</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 4</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 5</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 6</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 7</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 8</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 9</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 10</div>
            <div class="grid-item" onclick="toggleStatus(this)">* J</div>
            <div class="grid-item" onclick="toggleStatus(this)">* Q</div>
            <div class="grid-item" onclick="toggleStatus(this)">* K</div>
            <div class="grid-item" onclick="toggleStatus(this)">* A</div>
            
            <!-- 第五行：3-5, 6-8, 9-10, J-Q-K-A -->
            <div class="grid-item" onclick="toggleStatus(this)">* 3</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 4</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 5</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 6</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 7</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 8</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 9</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 10</div>
            <div class="grid-item" onclick="toggleStatus(this)">* J</div>
            <div class="grid-item" onclick="toggleStatus(this)">* Q</div>
            <div class="grid-item" onclick="toggleStatus(this)">* K</div>
            <div class="grid-item" onclick="toggleStatus(this)">* A</div>
            
            <!-- 第六行：3-5, 6-8, 9-10, J-Q-K-A -->
            <div class="grid-item" onclick="toggleStatus(this)">* 3</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 4</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 5</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 6</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 7</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 8</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 9</div>
            <div class="grid-item" onclick="toggleStatus(this)">* 10</div>
            <div class="grid-item" onclick="toggleStatus(this)">* J</div>
            <div class="grid-item" onclick="toggleStatus(this)">* Q</div>
            <div class="grid-item" onclick="toggleStatus(this)">* K</div>
            <div class="grid-item" onclick="toggleStatus(this)">* A</div>
        </div>
        
        <!-- 游戏消息提示（放在卡牌网格下方） -->
        <div class="game-message" id="gameMessage" style="display: none;">
            <h4 id="messageText">游戏失败！</h4>
            <button onclick="restartGame()">重新开始</button>
        </div>
    </div>
    
    <script>
        // 存储生成的二进制编码
        let currentBinaryCode = '';
        
        // 状态切换函数（通过添加/移除active类改变背景颜色）
        function toggleStatus(element) {
            if (element.classList.contains('active')) {
                element.classList.remove('active');
            } else {
                element.classList.add('active');
            }
        }
        
        // 生成随机二进制编码并按照当前模式渲染卡片
        function generateRandomBinary() {
            // 生成54位随机二进制数字
            let binary = '';
            for (let i = 0; i < 54; i++) {
                binary += Math.floor(Math.random() * 2);
            }
            
            // 每四位添加一个空格分隔
            let formattedBinary = '';
            for (let i = 0; i < binary.length; i++) {
                if (i > 0 && i % 4 === 0) {
                    formattedBinary += ' ';
                }
                formattedBinary += binary[i];
            }
            
            currentBinaryCode = binary;
            
            // 清除所有卡片的状态
            clearAllCards();
            
            if (suitMode) {
                // 有花色模式：直接显示
                renderWithSuits(binary);
            } else {
                // 无花色模式：堆叠显示
                renderWithoutSuits(binary);
            }
            
            // 显示二进制编码
            document.getElementById('binaryCode').textContent = `生成的二进制编码: ${formattedBinary}`;
        }
        
        // 有花色模式渲染（直接显示）
        function renderWithSuits(binary) {
            // 收集所有可点击的卡片元素
            const cards = document.querySelectorAll('.grid-container > div');
            
            // 按照用户要求的映射关系排序卡片
            const orderedCards = [];
            
            // 收集所有3的卡片
            cards.forEach(card => {
                if (card.textContent.includes('3') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有4的卡片
            cards.forEach(card => {
                if (card.textContent.includes('4') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有5的卡片
            cards.forEach(card => {
                if (card.textContent.includes('5') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有6的卡片
            cards.forEach(card => {
                if (card.textContent.includes('6') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有7的卡片
            cards.forEach(card => {
                if (card.textContent.includes('7') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有8的卡片
            cards.forEach(card => {
                if (card.textContent.includes('8') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有9的卡片
            cards.forEach(card => {
                if (card.textContent.includes('9') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有10的卡片
            cards.forEach(card => {
                if (card.textContent.includes('10') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有J的卡片
            cards.forEach(card => {
                if (card.textContent.includes('J') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有Q的卡片
            cards.forEach(card => {
                if (card.textContent.includes('Q') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有K的卡片
            cards.forEach(card => {
                if (card.textContent.includes('K') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有A的卡片
            cards.forEach(card => {
                if (card.textContent.includes('A') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有2的卡片
            cards.forEach(card => {
                if (card.textContent.includes('2') && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 收集所有王的卡片
            cards.forEach(card => {
                if ((card.textContent.includes('小王') || card.textContent.includes('大王')) && card.hasAttribute('onclick')) {
                    orderedCards.push(card);
                }
            });
            
            // 直接显示对应的卡片
            for (let i = 0; i < 54 && i < orderedCards.length; i++) {
                if (binary[i] === '1') {
                    orderedCards[i].classList.add('active');
                }
            }
        }
        
        // 无花色模式渲染（堆叠显示）
        function renderWithoutSuits(binary) {
            // 收集所有可点击的卡片元素并分组
            const cards = document.querySelectorAll('.grid-container > div');
            
            // 分组映射：3-10, J-Q-K-A, 2, 王
            const groups = {
                '3': [],
                '4': [],
                '5': [],
                '6': [],
                '7': [],
                '8': [],
                '9': [],
                '10': [],
                'J': [],
                'Q': [],
                'K': [],
                'A': [],
                '2': [],
                '王': []
            };
            
            // 收集卡片到对应分组
            cards.forEach(card => {
                const text = card.textContent;
                if (text.includes('3') && card.hasAttribute('onclick')) groups['3'].push(card);
                else if (text.includes('4') && card.hasAttribute('onclick')) groups['4'].push(card);
                else if (text.includes('5') && card.hasAttribute('onclick')) groups['5'].push(card);
                else if (text.includes('6') && card.hasAttribute('onclick')) groups['6'].push(card);
                else if (text.includes('7') && card.hasAttribute('onclick')) groups['7'].push(card);
                else if (text.includes('8') && card.hasAttribute('onclick')) groups['8'].push(card);
                else if (text.includes('9') && card.hasAttribute('onclick')) groups['9'].push(card);
                else if (text.includes('10') && card.hasAttribute('onclick')) groups['10'].push(card);
                else if (text.includes('J') && card.hasAttribute('onclick')) groups['J'].push(card);
                else if (text.includes('Q') && card.hasAttribute('onclick')) groups['Q'].push(card);
                else if (text.includes('K') && card.hasAttribute('onclick')) groups['K'].push(card);
                else if (text.includes('A') && card.hasAttribute('onclick')) groups['A'].push(card);
                else if (text.includes('2') && card.hasAttribute('onclick')) groups['2'].push(card);
                else if ((text.includes('小王') || text.includes('大王')) && card.hasAttribute('onclick')) groups['王'].push(card);
            });
            
            // 按照顺序排列分组
            const groupOrder = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2', '王'];
            
            // 处理二进制数据，每4位一组
            let binaryIndex = 0;
            
            // 处理数字和字母卡片（从底部向上渲染）
            for (let i = 0; i < groupOrder.length - 2; i++) { // 排除2和王
                const group = groups[groupOrder[i]];
                if (group.length > 0) {
                    // 统计当前组的1的个数
                    let count = 0;
                    for (let j = 0; j < 4 && binaryIndex < 54; j++) {
                        if (binary[binaryIndex] === '1') {
                            count++;
                        }
                        binaryIndex++;
                    }
                    
                    // 从底部向上渲染
                    for (let j = group.length - 1; j >= 0 && count > 0; j--) {
                        group[j].classList.add('active');
                        count--;
                    }
                }
            }
            
            // 处理2的卡片（横向渲染，从左到右）
            const twoGroup = groups['2'];
            if (twoGroup.length > 0) {
                let count = 0;
                for (let j = 0; j < 4 && binaryIndex < 54; j++) {
                    if (binary[binaryIndex] === '1') {
                        count++;
                    }
                    binaryIndex++;
                }
                
                // 横向渲染，从左到右
                for (let j = 0; j < twoGroup.length && count > 0; j++) {
                    twoGroup[j].classList.add('active');
                    count--;
                }
            }
            
            // 处理王的卡片（横向渲染，从左到右）
            const kingGroup = groups['王'];
            if (kingGroup.length > 0) {
                let count = 0;
                for (let j = 0; j < 2 && binaryIndex < 54; j++) {
                    if (binary[binaryIndex] === '1') {
                        count++;
                    }
                    binaryIndex++;
                }
                
                // 横向渲染，从左到右
                for (let j = 0; j < kingGroup.length && count > 0; j++) {
                    kingGroup[j].classList.add('active');
                    count--;
                }
            }
        }
        
        // 清除所有卡片的状态
        function clearAllCards() {
            const cards = document.querySelectorAll('.grid-container > div');
            cards.forEach(card => {
                card.classList.remove('active');
            });
            
            // 保持二进制编码框的默认文字
            if (!currentBinaryCode) {
                document.getElementById('binaryCode').textContent = '生成的二进制编码: ';
            }
        }
        
        // 花色模式切换
        let suitMode = false; // 默认无花色模式
        
        function toggleSuitMode() {
            suitMode = !suitMode;
            const button = document.getElementById('suitModeButton');
            
            if (suitMode) {
                button.textContent = '有花色模式';
                updateCardsWithSuits();
            } else {
                button.textContent = '无花色模式';
                updateCardsWithoutSuits();
            }
            
            // 如果已经有二进制编码，重新渲染
            if (currentBinaryCode) {
                clearAllCards();
                if (suitMode) {
                    renderWithSuits(currentBinaryCode);
                } else {
                    renderWithoutSuits(currentBinaryCode);
                }
            }
            
            // 如果在游戏模式中，重新渲染游戏进度
            if (gameMode && gameState.isPlaying) {
                // 清除所有卡片的激活状态
                clearAllCards();
                
                // 重新渲染已完成的卡片
                for (let i = 0; i < gameState.currentIndex && i < gameState.shuffledCards.length; i++) {
                    const card = gameState.shuffledCards[i];
                    
                    if (suitMode) {
                        // 有花色模式：在正确的区域显示颜色变化
                        const allCards = document.querySelectorAll('.grid-container > div');
                        allCards.forEach(c => {
                            if (c.textContent === card.display) {
                                c.classList.add('active');
                            }
                        });
                    } else {
                        // 无花色模式：按照无花色模式的渲染方式进行
                        // 找到所有卡片并分组
                        const allCards = document.querySelectorAll('.grid-container > div');
                        
                        // 分组映射：3-10, J-Q-K-A, 2, 王
                        const groups = {
                            '3': [],
                            '4': [],
                            '5': [],
                            '6': [],
                            '7': [],
                            '8': [],
                            '9': [],
                            '10': [],
                            'J': [],
                            'Q': [],
                            'K': [],
                            'A': [],
                            '2': [],
                            '王': []
                        };
                        
                        // 收集卡片到对应分组
                        allCards.forEach(c => {
                            const text = c.textContent;
                            if (text.includes('3') && c.hasAttribute('onclick')) groups['3'].push(c);
                            else if (text.includes('4') && c.hasAttribute('onclick')) groups['4'].push(c);
                            else if (text.includes('5') && c.hasAttribute('onclick')) groups['5'].push(c);
                            else if (text.includes('6') && c.hasAttribute('onclick')) groups['6'].push(c);
                            else if (text.includes('7') && c.hasAttribute('onclick')) groups['7'].push(c);
                            else if (text.includes('8') && c.hasAttribute('onclick')) groups['8'].push(c);
                            else if (text.includes('9') && c.hasAttribute('onclick')) groups['9'].push(c);
                            else if (text.includes('10') && c.hasAttribute('onclick')) groups['10'].push(c);
                            else if (text.includes('J') && c.hasAttribute('onclick')) groups['J'].push(c);
                            else if (text.includes('Q') && c.hasAttribute('onclick')) groups['Q'].push(c);
                            else if (text.includes('K') && c.hasAttribute('onclick')) groups['K'].push(c);
                            else if (text.includes('A') && c.hasAttribute('onclick')) groups['A'].push(c);
                            else if (text.includes('2') && c.hasAttribute('onclick')) groups['2'].push(c);
                            else if ((text.includes('小王') || text.includes('大王')) && c.hasAttribute('onclick')) groups['王'].push(c);
                        });
                        
                        // 根据卡片的值选择对应的分组进行处理
                        if (card.value === '2') {
                            // 对于2的卡片：从左侧开始排列
                            const twoGroup = groups['2'];
                            if (twoGroup.length > 0) {
                                // 找到第一个未激活的卡片
                                for (let j = 0; j < twoGroup.length; j++) {
                                    if (!twoGroup[j].classList.contains('active')) {
                                        twoGroup[j].classList.add('active');
                                        break;
                                    }
                                }
                            }
                        } else if (card.value === '小王' || card.value === '大王') {
                            // 对于大小王：分别排列
                            const kingGroup = groups['王'];
                            if (kingGroup.length > 0) {
                                // 找到对应的王卡片
                                kingGroup.forEach(c => {
                                    if (c.textContent === card.display && !c.classList.contains('active')) {
                                        c.classList.add('active');
                                    }
                                });
                            }
                        } else {
                            // 对于数字和字母卡片：从底部向上渲染
                            const group = groups[card.value];
                            if (group.length > 0) {
                                // 找到第一个从底部开始未激活的卡片
                                for (let j = group.length - 1; j >= 0; j--) {
                                    if (!group[j].classList.contains('active')) {
                                        group[j].classList.add('active');
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // 更新卡片为有花色模式
        function updateCardsWithSuits() {
            // 处理2的卡片
            const twoCards = document.querySelectorAll('.grid-container .two-item');
            const suits = ['♠', '♥', '♣', '♦'];
            if (twoCards.length >= 4) {
                for (let i = 0; i < 4; i++) {
                    twoCards[i].textContent = suits[i] + ' 2';
                }
            }
            
            // 处理第三行：黑桃（用户的第三行，对应HTML中的第25-36个元素）
            const spadesRow = document.querySelectorAll('.grid-container > div:nth-child(n+25):nth-child(-n+36)');
            const values = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            spadesRow.forEach((card, index) => {
                if (card && !card.classList.contains('empty-card')) {
                    card.textContent = '♠ ' + values[index];
                }
            });
            
            // 处理第四行：红桃（用户的第四行，对应HTML中的第37-48个元素）
            const heartsRow = document.querySelectorAll('.grid-container > div:nth-child(n+37):nth-child(-n+48)');
            heartsRow.forEach((card, index) => {
                if (card && !card.classList.contains('empty-card')) {
                    card.textContent = '♥ ' + values[index];
                }
            });
            
            // 处理第五行：梅花（用户的第五行，对应HTML中的第49-60个元素）
            const clubsRow = document.querySelectorAll('.grid-container > div:nth-child(n+49):nth-child(-n+60)');
            clubsRow.forEach((card, index) => {
                if (card && !card.classList.contains('empty-card')) {
                    card.textContent = '♣ ' + values[index];
                }
            });
            
            // 处理第六行：方片（用户的第六行，对应HTML中的第61-72个元素）
            const diamondsRow = document.querySelectorAll('.grid-container > div:nth-child(n+61):nth-child(-n+72)');
            diamondsRow.forEach((card, index) => {
                if (card && !card.classList.contains('empty-card')) {
                    card.textContent = '♦ ' + values[index];
                }
            });
        }
        
        // 更新卡片为无花色模式
        function updateCardsWithoutSuits() {
            const cards = document.querySelectorAll('.grid-container > div');
            
            cards.forEach(card => {
                const text = card.textContent;
                if (text.includes(' 2')) {
                    card.textContent = '* 2';
                } else if (text.includes(' 3')) {
                    card.textContent = '* 3';
                } else if (text.includes(' 4')) {
                    card.textContent = '* 4';
                } else if (text.includes(' 5')) {
                    card.textContent = '* 5';
                } else if (text.includes(' 6')) {
                    card.textContent = '* 6';
                } else if (text.includes(' 7')) {
                    card.textContent = '* 7';
                } else if (text.includes(' 8')) {
                    card.textContent = '* 8';
                } else if (text.includes(' 9')) {
                    card.textContent = '* 9';
                } else if (text.includes(' 10')) {
                    card.textContent = '* 10';
                } else if (text.includes(' J')) {
                    card.textContent = '* J';
                } else if (text.includes(' Q')) {
                    card.textContent = '* Q';
                } else if (text.includes(' K')) {
                    card.textContent = '* K';
                } else if (text.includes(' A')) {
                    card.textContent = '* A';
                }
            });
        }
        
        // 布局模式切换
        let layoutMode = false; // 默认布局模式
        
        function toggleLayoutMode() {
            layoutMode = !layoutMode;
            const button = document.getElementById('layoutModeButton');
            
            if (layoutMode) {
                button.textContent = '右对齐布局';
                updateLayoutRightAlign();
            } else {
                button.textContent = '默认布局';
                updateLayoutDefault();
            }
        }
        
        // 更新为默认布局
        function updateLayoutDefault() {
            // 第一行：大小王（第6、7格）
            const kingCards = document.querySelectorAll('.grid-container > div');
            kingCards.forEach(card => {
                if (card.textContent.includes('小王')) {
                    card.style.gridColumn = '6';
                    card.style.gridRow = '1';
                } else if (card.textContent.includes('大王')) {
                    card.style.gridColumn = '7';
                    card.style.gridRow = '1';
                }
            });
            
            // 第二行：2的四张牌（中间四个，第5-8格）
            const twoCards = document.querySelectorAll('.grid-container .two-item');
            if (twoCards.length >= 4) {
                twoCards[0].style.gridColumn = '5';
                twoCards[0].style.gridRow = '2';
                twoCards[1].style.gridColumn = '6';
                twoCards[1].style.gridRow = '2';
                twoCards[2].style.gridColumn = '7';
                twoCards[2].style.gridRow = '2';
                twoCards[3].style.gridColumn = '8';
                twoCards[3].style.gridRow = '2';
            }
        }
        
        // 更新为右对齐布局
        function updateLayoutRightAlign() {
            // 第一行：大小王（小王第11格，大王第12格）
            const kingCards = document.querySelectorAll('.grid-container > div');
            kingCards.forEach(card => {
                if (card.textContent.includes('小王')) {
                    card.style.gridColumn = '11'; // 第11列
                    card.style.gridRow = '1';
                } else if (card.textContent.includes('大王')) {
                    card.style.gridColumn = '12'; // 第12列
                    card.style.gridRow = '1';
                }
            });
            
            // 第二行：2的四张牌（第9-12格）
            const twoCards = document.querySelectorAll('.grid-container .two-item');
            if (twoCards.length >= 4) {
                twoCards[0].style.gridColumn = '9'; // 第9列
                twoCards[0].style.gridRow = '2';
                twoCards[1].style.gridColumn = '10'; // 第10列
                twoCards[1].style.gridRow = '2';
                twoCards[2].style.gridColumn = '11'; // 第11列
                twoCards[2].style.gridRow = '2';
                twoCards[3].style.gridColumn = '12'; // 第12列
                twoCards[3].style.gridRow = '2';
            }
        }
        
        // 游戏模式
        let gameMode = false; // 默认游戏模式关闭
        let gameState = {
            isPlaying: false,
            currentIndex: 0,
            shuffledCards: [],
            correctCount: 0,
            wrongCount: 0,
            speed: 1.0,
            baseSpeed: 1.0,
            acceleration: 0.01,
            scrollPosition: 0,
            scrollSpeed: 2,
            gameTimer: null,
            startTime: 0,
            isFirstCorrect: true // 是否是第一次正确点击
        };
        

        
        // 卡片映射数组（按照用户要求的顺序）
        const cardMap = [];
        
        // 初始化卡片映射
        function initCardMap() {
            // 花色顺序：黑桃、红桃、梅花、方片
            const suits = ['♠', '♥', '♣', '♦'];
            // 牌值顺序：3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A, 2
            const values = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
            
            // 生成所有牌的映射
            let index = 1;
            for (const value of values) {
                for (const suit of suits) {
                    cardMap.push({ value: value, suit: suit, display: suit + ' ' + value, order: index });
                    index++;
                }
            }
            
            // 添加小王和大王
            cardMap.push({ value: '小王', suit: '', display: '小王', order: 53 });
            cardMap.push({ value: '大王', suit: '', display: '大王', order: 54 });
        }
        
        // 初始化卡片映射
        initCardMap();
        
        // 游戏模式切换
        function toggleGameMode() {
            gameMode = !gameMode;
            const button = document.getElementById('gameModeButton');
            const gameModeDiv = document.getElementById('gameMode');
            const binaryCodeDiv = document.getElementById('binaryCode');
            
            if (gameMode) {
                button.textContent = '退出游戏';
                gameModeDiv.style.display = 'block';
                binaryCodeDiv.style.display = 'none'; // 进入游戏模式时隐藏二进制编码框
                // 进入游戏模式后直接初始化游戏状态并生成卡片序列，但不开始滚动
                initGameMode();
            } else {
                button.textContent = '游戏模式';
                gameModeDiv.style.display = 'none';
                binaryCodeDiv.style.display = 'block'; // 退出游戏模式时显示二进制编码框
                endGame();
            }
        }
        
        // 初始化游戏模式
        function initGameMode() {
            // 隐藏游戏消息
            document.getElementById('gameMessage').style.display = 'none';
            
            // 清除所有卡片的激活状态
            clearAllCards();
            
            // 重置游戏状态
            gameState = {
                isPlaying: false,
                currentIndex: 0,
                shuffledCards: [],
                correctCount: 0,
                wrongCount: 0,
                speed: 1.0, // 默认初始速度
                baseSpeed: 1.0, // 默认基础速度
                acceleration: 0.01, // 默认加速度
                scrollPosition: 0,
                scrollSpeed: 2, // 默认滚动速度
                gameTimer: null,
                startTime: 0,
                isFirstCorrect: true // 是否是第一次正确点击
            };
            
            // 生成随机排列（Fisher-Yates洗牌算法）
            gameState.shuffledCards = [...cardMap].sort(() => Math.random() - 0.5);
            
            // 生成卡片序列
            generateCardSequence();
            
            // 重置滚动位置
            const sequenceContainer = document.getElementById('cardSequence');
            gameState.scrollPosition = 0;
            sequenceContainer.scrollLeft = 0;
            
            // 更新游戏界面
            updateGameUI();
            
            // 显示第一张卡片
            showNextCard();
        }
        
        // 重新开始游戏
        function restartGame() {
            // 隐藏游戏消息
            document.getElementById('gameMessage').style.display = 'none';
            
            // 清除所有卡片的激活状态
            clearAllCards();
            
            // 重置游戏状态
            gameState = {
                isPlaying: false,
                currentIndex: 0,
                shuffledCards: [],
                correctCount: 0,
                wrongCount: 0,
                speed: 1.0, // 默认初始速度
                baseSpeed: 1.0, // 默认基础速度
                acceleration: 0.01, // 默认加速度
                scrollPosition: 0,
                scrollSpeed: 2, // 默认滚动速度
                gameTimer: null,
                startTime: 0,
                isFirstCorrect: true // 是否是第一次正确点击
            };
            
            // 生成随机排列（Fisher-Yates洗牌算法）
            gameState.shuffledCards = [...cardMap].sort(() => Math.random() - 0.5);
            
            // 生成卡片序列
            generateCardSequence();
            
            // 重置滚动位置
            const sequenceContainer = document.getElementById('cardSequence');
            gameState.scrollPosition = 0;
            sequenceContainer.scrollLeft = 0;
            
            // 更新游戏界面
            updateGameUI();
            
            // 显示第一张卡片
            showNextCard();
        }
        

        
        // 生成卡片序列
        function generateCardSequence() {
            const sequenceContainer = document.getElementById('cardSequence');
            sequenceContainer.innerHTML = '';
            
            // 添加2个占位卡片（前面）
            for (let i = 0; i < 2; i++) {
                const placeholderCard = document.createElement('div');
                placeholderCard.className = 'sequence-card';
                placeholderCard.textContent = '';
                placeholderCard.style.backgroundColor = 'transparent';
                placeholderCard.style.borderColor = 'transparent';
                sequenceContainer.appendChild(placeholderCard);
            }
            
            // 为每张卡片创建一个序列卡片
            gameState.shuffledCards.forEach((card, index) => {
                const sequenceCard = document.createElement('div');
                sequenceCard.className = 'sequence-card';
                sequenceCard.textContent = card.display;
                sequenceCard.dataset.index = index;
                sequenceContainer.appendChild(sequenceCard);
            });
            
            // 添加2个占位卡片（后面）
            for (let i = 0; i < 2; i++) {
                const placeholderCard = document.createElement('div');
                placeholderCard.className = 'sequence-card';
                placeholderCard.textContent = '';
                placeholderCard.style.backgroundColor = 'transparent';
                placeholderCard.style.borderColor = 'transparent';
                sequenceContainer.appendChild(placeholderCard);
            }
        }
        
        // 更新卡片序列
        function updateCardSequence() {
            const sequenceCards = document.querySelectorAll('.sequence-card');
            const sequenceContainer = document.getElementById('cardSequence');
            
            // 标记已完成的卡片和当前卡片
            sequenceCards.forEach((card, index) => {
                if (index < gameState.currentIndex + 2) { // +2 因为前面有2个占位卡片
                    // 已完成的卡片
                    card.classList.add('completed');
                    card.classList.remove('current');
                } else if (index === gameState.currentIndex + 2) { // +2 因为前面有2个占位卡片
                    // 当前需要输入的卡片
                    card.classList.remove('completed');
                    card.classList.add('current');
                } else {
                    // 未完成的卡片
                    card.classList.remove('completed');
                    card.classList.remove('current');
                }
            });
        }

        // 游戏主循环
        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            const sequenceContainer = document.getElementById('cardSequence');
            const sequenceCards = document.querySelectorAll('.sequence-card');
            
            // 更新滚动位置
            gameState.scrollPosition += gameState.scrollSpeed * gameState.speed;
            
            // 更可靠的卡片宽度计算：直接获取实际卡片元素的宽度
            let cardWidth = 50; // 默认值
            if (sequenceCards.length > 0) {
                cardWidth = sequenceCards[0].offsetWidth + 10; // 实际卡片宽度 + 间距
            }
            const targetCardIndex = gameState.currentIndex + 2; // +2 因为前面有2个占位卡片
            const targetCardPosition = targetCardIndex * cardWidth;
            
            // 获取容器宽度
            const containerWidth = sequenceContainer.offsetWidth;
            
            // 计算高亮卡片左侧与显示窗口左侧的距离
            const cardLeft = targetCardPosition;
            const distance = cardLeft - gameState.scrollPosition;
            
            // 直接判断：当卡片左侧边缘完全移出窗口右侧时，触发游戏失败
            // 当distance < -cardWidth时，说明卡片已经完全移出窗口
            if (distance < -cardWidth) {
                gameOver(false);
                return;
            }
            
            // 更新容器滚动位置
            sequenceContainer.scrollLeft = gameState.scrollPosition;
            
            // 逐渐增加速度，但设置合理的上限
            gameState.speed = Math.min(
                gameState.baseSpeed + (gameState.correctCount * gameState.acceleration),
                3.0 // 最大速度限制
            );
            document.getElementById('gameSpeed').textContent = gameState.speed.toFixed(1) + 'x';
            
            // 继续游戏循环
            gameState.gameTimer = requestAnimationFrame(gameLoop);
        }
        
        // 结束游戏
        function endGame() {
            gameState.isPlaying = false;
            
            // 清除游戏定时器
            if (gameState.gameTimer) {
                cancelAnimationFrame(gameState.gameTimer);
                gameState.gameTimer = null;
            }
            

            
            clearAllCards();
        }

        // 游戏结束处理
        function gameOver(isWin) {
            gameState.isPlaying = false;
            
            // 清除游戏定时器
            if (gameState.gameTimer) {
                cancelAnimationFrame(gameState.gameTimer);
                gameState.gameTimer = null;
            }
            

            
            // 显示游戏结果
            const gameMessage = document.getElementById('gameMessage');
            const messageText = document.getElementById('messageText');
            
            if (isWin) {
                const endTime = Date.now();
                const duration = (endTime - gameState.startTime) / 1000;
                const speed = (gameState.correctCount / duration).toFixed(2);
                messageText.innerHTML = `游戏胜利！<br>用时: ${duration.toFixed(2)}秒<br>正确率: ${Math.round(gameState.correctCount / 54 * 100)}%<br>速度: ${speed}卡/秒`;
            } else {
                messageText.textContent = '游戏失败！高亮框移出视野';
            }
            
            gameMessage.style.display = 'block';
        }
        
        // 更新游戏界面
        function updateGameUI() {
            document.getElementById('gameProgress').textContent = `${gameState.currentIndex}/54`;
            document.getElementById('gameCorrect').textContent = gameState.correctCount;
            document.getElementById('gameWrong').textContent = gameState.wrongCount;
        }
        
        // 显示下一张卡片
        function showNextCard() {
            if (gameState.currentIndex >= 54) {
                // 游戏胜利
                gameOver(true);
                return;
            }
            
            // 更新游戏界面
            updateGameUI();
            
            // 更新卡片序列
            updateCardSequence();
        }
        
        // 检查用户点击的卡片是否正确
        function checkCardClick(cardElement) {
            if (!gameMode) return;
            
            const clickedCardText = cardElement.textContent;
            const currentCard = gameState.shuffledCards[gameState.currentIndex];
            
            // 检查是否正确：
            // 1. 对于大小王，必须完全匹配
            // 2. 对于其他卡片，只需要匹配数字部分
            let isCorrect = false;
            
            if (currentCard.value === '小王' || currentCard.value === '大王') {
                // 大小王必须完全匹配
                isCorrect = (clickedCardText === currentCard.display);
            } else {
                // 其他卡片只需要匹配数字部分
                // 提取点击卡片的数字部分
                const clickedValue = clickedCardText.replace(/[^0-9JQKA]/g, '').trim();
                // 提取当前卡片的数字部分
                const currentValue = currentCard.value;
                isCorrect = (clickedValue === currentValue);
            }
            
            if (isCorrect) {
                // 正确
                if (suitMode) {
                    // 有花色模式：在正确的区域显示颜色变化
                    // 找到与当前卡片完全匹配的卡片
                    const allCards = document.querySelectorAll('.grid-container > div');
                    allCards.forEach(card => {
                        if (card.textContent === currentCard.display) {
                            card.classList.add('active');
                        }
                    });
                } else {
                    // 无花色模式：按照无花色模式的渲染方式进行
                    // 找到所有卡片并分组
                    const allCards = document.querySelectorAll('.grid-container > div');
                    
                    // 分组映射：3-10, J-Q-K-A, 2, 王
                    const groups = {
                        '3': [],
                        '4': [],
                        '5': [],
                        '6': [],
                        '7': [],
                        '8': [],
                        '9': [],
                        '10': [],
                        'J': [],
                        'Q': [],
                        'K': [],
                        'A': [],
                        '2': [],
                        '王': []
                    };
                    
                    // 收集卡片到对应分组
                    allCards.forEach(card => {
                        const text = card.textContent;
                        if (text.includes('3') && card.hasAttribute('onclick')) groups['3'].push(card);
                        else if (text.includes('4') && card.hasAttribute('onclick')) groups['4'].push(card);
                        else if (text.includes('5') && card.hasAttribute('onclick')) groups['5'].push(card);
                        else if (text.includes('6') && card.hasAttribute('onclick')) groups['6'].push(card);
                        else if (text.includes('7') && card.hasAttribute('onclick')) groups['7'].push(card);
                        else if (text.includes('8') && card.hasAttribute('onclick')) groups['8'].push(card);
                        else if (text.includes('9') && card.hasAttribute('onclick')) groups['9'].push(card);
                        else if (text.includes('10') && card.hasAttribute('onclick')) groups['10'].push(card);
                        else if (text.includes('J') && card.hasAttribute('onclick')) groups['J'].push(card);
                        else if (text.includes('Q') && card.hasAttribute('onclick')) groups['Q'].push(card);
                        else if (text.includes('K') && card.hasAttribute('onclick')) groups['K'].push(card);
                        else if (text.includes('A') && card.hasAttribute('onclick')) groups['A'].push(card);
                        else if (text.includes('2') && card.hasAttribute('onclick')) groups['2'].push(card);
                        else if ((text.includes('小王') || text.includes('大王')) && card.hasAttribute('onclick')) groups['王'].push(card);
                    });
                    
                    // 根据当前卡片的值选择对应的分组进行处理
                    if (currentCard.value === '2') {
                        // 对于2的卡片：从左侧开始排列
                        const twoGroup = groups['2'];
                        if (twoGroup.length > 0) {
                            // 找到第一个未激活的卡片
                            for (let i = 0; i < twoGroup.length; i++) {
                                if (!twoGroup[i].classList.contains('active')) {
                                    twoGroup[i].classList.add('active');
                                    break;
                                }
                            }
                        }
                    } else if (currentCard.value === '小王' || currentCard.value === '大王') {
                        // 对于大小王：分别排列
                        const kingGroup = groups['王'];
                        if (kingGroup.length > 0) {
                            // 找到对应的王卡片
                            kingGroup.forEach(card => {
                                if (card.textContent === currentCard.display && !card.classList.contains('active')) {
                                    card.classList.add('active');
                                }
                            });
                        }
                    } else {
                        // 对于数字和字母卡片：从底部向上渲染
                        const group = groups[currentCard.value];
                        if (group.length > 0) {
                            // 找到第一个从底部开始未激活的卡片
                            for (let i = group.length - 1; i >= 0; i--) {
                                if (!group[i].classList.contains('active')) {
                                    group[i].classList.add('active');
                                    break;
                                }
                            }
                        }
                    }
                }
                
                gameState.correctCount++;
                gameState.currentIndex++;
                
                // 重置最小距离记录，确保下一张卡片的判断不受影响
                gameState.minDistance = Infinity;
                
                // 不需要强制使高亮框居中，让滚动条按照正常速度滚动
                
                // 如果是第一次正确点击，自动开始游戏
                if (gameState.isFirstCorrect) {
                    gameState.isFirstCorrect = false;
                    gameState.isPlaying = true;
                    gameState.startTime = Date.now();
                    // 开始游戏循环
                    gameState.gameTimer = requestAnimationFrame(gameLoop);
                }
                
                showNextCard();
            } else {
                // 错误
                gameState.wrongCount++;
                updateGameUI();
            }
        }
        
        // 修改toggleStatus函数，添加游戏模式的卡片点击检查
        function toggleStatus(element) {
            if (gameMode) {
                // 在游戏模式下，无论isPlaying是否为true，都调用checkCardClick函数
                checkCardClick(element);
            } else {
                if (element.classList.contains('active')) {
                    element.classList.remove('active');
                } else {
                    element.classList.add('active');
                }
            }
        }
        
        // 键盘按键映射
        function initKeyboardMapping() {
            // 获取所有卡片
            const allCards = document.querySelectorAll('.grid-container > div');
            
            // 按键映射：调整为用户要求的映射关系
            const keyMapping = {
                'a': '3',
                's': '4',
                'd': '5',
                'f': '6',
                'r': '7',
                't': '8',
                'y': '9',
                'u': '10',
                'j': 'J',
                'k': 'Q',
                'l': 'K',
                ';': 'A',
                'g': '2', // g对应左侧2
                'h': '2', // h对应左侧2
                'e': '小王', // e对应小王
                'i': '大王' // i对应大王
            };
            
            // 添加键盘事件监听器
            document.addEventListener('keydown', function(event) {
                const key = event.key;
                const mappedValue = keyMapping[key];
                
                if (mappedValue) {
                    // 查找对应的卡片
                    allCards.forEach(card => {
                        if (card.hasAttribute('onclick')) {
                            const cardText = card.textContent;
                            
                            if (mappedValue === '小王' || mappedValue === '大王') {
                                // 处理大小王
                                if (cardText === mappedValue) {
                                    toggleStatus(card);
                                }
                            } else if (mappedValue === '2') {
                                // 处理2的卡片，选择最左侧的2
                                // 收集所有带有two-item类的卡片
                                const twoCards = document.querySelectorAll('.grid-container .two-item');
                                // 只选择最左侧的2卡片
                                if (twoCards.length > 0) {
                                    toggleStatus(twoCards[0]);
                                }
                            } else {
                                // 处理数字和字母卡片，选择最底部那行的对应卡片
                                // 对于数字卡片，使用更宽松的匹配方式
                                const isNumberMatch = !isNaN(mappedValue) && cardText.includes(mappedValue);
                                // 对于字母卡片，使用精确匹配
                                const isLetterMatch = isNaN(mappedValue) && cardText.includes(mappedValue);
                                
                                if (isNumberMatch || isLetterMatch) {
                                    // 检查是否是最底部那行的卡片（第61-72个元素，从0开始索引）
                                    const cardIndex = Array.from(allCards).indexOf(card);
                                    if (cardIndex >= 60 && cardIndex <= 71) { // 调整为0-based索引
                                        toggleStatus(card);
                                    }
                                }
                            }
                        }
                    });
                }
            });
        }
        
        // 初始化键盘映射
        initKeyboardMapping();
        
        // 初始化设置控件
        initSettingsControls();
        
        // 切换设置窗口
        function toggleSettings() {
            settingsVisible = !settingsVisible;
            const settingsWindow = document.getElementById('settingsWindow');
            
            if (settingsVisible) {
                settingsWindow.style.display = 'block';
            } else {
                settingsWindow.style.display = 'none';
            }
        }
        
        // 保存设置
        function saveSettings() {
            const initialSpeed = parseFloat(document.getElementById('initialSpeed').value);
            const speedDuration = parseInt(document.getElementById('speedDuration').value) * 1000; // 转换为毫秒
            const speedIncreasePercent = parseInt(document.getElementById('speedIncrease').value);
            
            // 更新游戏状态中的设置
            gameState.baseSpeed = initialSpeed;
            gameState.speedDuration = speedDuration;
            gameState.speedIncreasePercent = speedIncreasePercent;
            
            // 显示保存成功消息
            alert('设置已保存！');
        }
        
        // 初始化设置控件
        function initSettingsControls() {
            // 初始速度滑块
            const initialSpeedSlider = document.getElementById('initialSpeed');
            const initialSpeedValue = document.getElementById('initialSpeedValue');
            
            initialSpeedSlider.addEventListener('input', function() {
                initialSpeedValue.textContent = this.value;
            });
            
            // 速度持续时间滑块
            const speedDurationSlider = document.getElementById('speedDuration');
            const speedDurationValue = document.getElementById('speedDurationValue');
            
            speedDurationSlider.addEventListener('input', function() {
                speedDurationValue.textContent = this.value;
            });
            
            // 速度增加百分比滑块
            const speedIncreaseSlider = document.getElementById('speedIncrease');
            const speedIncreaseValue = document.getElementById('speedIncreaseValue');
            
            speedIncreaseSlider.addEventListener('input', function() {
                speedIncreaseValue.textContent = this.value;
            });
        }
        

    </script>
</body>
</html>
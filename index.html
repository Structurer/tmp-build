<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>游戏模式</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 布局参数 - 使用固定值作为默认值（800像素以上） */
        :root {
            /* 间距参数 */
            --column-gap: 5px; /* 基本列间间距 */
            --column-gap-1-2: 5px; /* 第1列和第2列之间的间距 */
            --column-gap-2-3: 5px; /* 第2列和第3列之间的间距 */
            --column-gap-3-4: 5px; /* 第3列和第4列之间的间距 */
            --column-gap-4-5: 20px; /* 第4列和第5列之间的间距 */
            --column-gap-5-6: 5px; /* 第5列和第6列之间的间距 */
            --column-gap-6-7: 5px; /* 第6列和第7列之间的间距 */
            --column-gap-7-8: 5px; /* 第7列和第8列之间的间距 */
            --column-gap-8-9: 20px; /* 第8列和第9列之间的间距 */
            --column-gap-9-10: 5px; /* 第9列和第10列之间的间距 */
            --column-gap-10-11: 5px; /* 第10列和第11列之间的间距 */
            --column-gap-11-12: 5px; /* 第11列和第12列之间的间距 */
            --column-gap-12-13: 5px; /* 第12列和第13列之间的间距 */
            --column-gap-13-14: 5px; /* 第13列和第14列之间的间距 */
            --column-gap-14-15: 5px; /* 第14列和第15列之间的间距 */

            --row-gap: 5px; /* 基本行间间距 */
            --row-gap-1-2: 20px; /* 第1行和第2行之间的间距 */
            --row-gap-2-3: 20px; /* 第2行和第3行之间的间距 */
            --row-gap-3-4: 5px; /* 第3行和第4行之间的间距 */
            --row-gap-4-5: 5px; /* 第4行和第5行之间的间距 */
            --row-gap-5-6: 5px; /* 第5行和第6行之间的间距 */
            
            /* 卡片尺寸参数 */
            --card-width: 50px; /* 卡片的宽度 */
            --card-height: 50px; /* 卡片的高度 */
            --card-padding: 0px; /* 卡片内边距 */
        }
        
        /* 响应式设计 - 在800像素以下使用vw单位实现等比例缩放 */
        @media (max-width: 800px) {
            :root {
                /* 间距参数 - 使用vw单位，实现等比例缩放 */
                --column-gap: 0.5vw; /* 减小间距以适应15列 */
                --column-gap-1-2: 0.5vw;
                --column-gap-2-3: 0.5vw;
                --column-gap-3-4: 0.5vw;
                --column-gap-4-5: 2vw; /* 减小间距以适应15列 */
                --column-gap-5-6: 0.5vw;
                --column-gap-6-7: 0.5vw;
                --column-gap-7-8: 0.5vw;
                --column-gap-8-9: 2vw; /* 减小间距以适应15列 */
                --column-gap-9-10: 0.5vw;
                --column-gap-10-11: 0.5vw;
                --column-gap-11-12: 0.5vw;
                --column-gap-12-13: 0.5vw;
                --column-gap-13-14: 0.5vw;
                --column-gap-14-15: 0.5vw;

                --row-gap: 0.5vw; /* 减小间距以适应15列 */
                --row-gap-1-2: 2vw; /* 减小间距以适应15列 */
                --row-gap-2-3: 2vw; /* 减小间距以适应15列 */
                --row-gap-3-4: 0.5vw;
                --row-gap-4-5: 0.5vw;
                --row-gap-5-6: 0.5vw;
                
                /* 卡片尺寸参数 - 使用vw单位，实现等比例缩放 */
                --card-width: 5.5vw; /* 减小卡片宽度以适应15列 */
                --card-height: 5.5vw; /* 减小卡片宽度以适应15列 */
            }
        }
        
        /* 进一步优化小屏幕显示 */
        @media (max-width: 600px) {
            :root {
                --card-width: 5vw; /* 进一步减小卡片宽度 */
                --card-height: 5vw; /* 进一步减小卡片宽度 */
                --column-gap: 0.4vw; /* 进一步减小间距 */
                --column-gap-4-5: 1.5vw; /* 进一步减小间距 */
                --column-gap-8-9: 1.5vw; /* 进一步减小间距 */
            }
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        /* 控制按钮样式 */
        .control-buttons {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-buttons button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .control-buttons button:hover {
            background-color: #45a049;
        }
        
        /* 速度控制样式 */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .speed-control label {
            font-size: 14px;
            color: #333;
            white-space: nowrap;
        }
        
        .speed-control input[type="range"] {
            width: 100px;
            cursor: pointer;
        }
        
        /* 游戏模式样式 */
        .game-mode {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* 卡片序列容器样式 - 使用flexbox确保垂直居中 */
        .card-sequence-container {
            position: relative;
            width: 100%; /* 宽度设置为100%，以充分利用容器空间 */
            max-width: 1200px; /* 设置最大宽度，避免过宽 */
            margin: 15px auto;
            height: calc(var(--card-height) * 2 + 40px); /* 增加高度，容纳更多卡片 */
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #2196f3;
            border-radius: 8px;
            background-color: #e3f2fd;
            padding: 10px;
        }

        /* 卡片序列样式 */
        .card-sequence {
            display: flex;
            gap: var(--column-gap-1-2);
            padding: var(--column-gap-1-2);
            border: 1px solid #bbdefb;
            border-radius: 4px;
            background-color: white;
            position: relative;
            z-index: 1;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }
        
        /* 卡片序列容器的边距和高度也会通过CSS变量自动响应式调整 */



        /* 训练消息样式 */
        .game-message {
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #4CAF50;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: relative;
            z-index: 10;
        }

        .game-message h4 {
            color: #4CAF50;
            margin-bottom: 15px;
        }

        .game-message button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .game-message button:hover {
            background-color: #45a049;
        }

        .sequence-card {
            flex: 0 0 auto;
            width: var(--card-width);
            height: var(--card-height);
            padding: var(--card-padding);
            background-color: #f5f5f5;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            color: #1976d2;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        
        .sequence-card.completed {
            opacity: 0.5;
            background-color: #e8f5e9;
            border-color: #c8e6c9;
        }
        
        .sequence-card.current {
            /* 高亮效果，明显提示当前需要输入的卡片 */
            background-color: #ffecb3;
            border: 3px solid #ffc107;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.7);
            transform: scale(1.1);
            transition: all 0.3s ease;
        }
        
        /* 闪动效果 */
        .sequence-card.flash {
            animation: flash 0.5s ease-in-out;
        }
        
        @keyframes flash {
            0% {
                background-color: #f5f5f5;
                border: 1px solid #bbdefb;
                box-shadow: none;
                transform: scale(1);
            }
            100% {
                background-color: #ffecb3;
                border: 3px solid #ffc107;
                box-shadow: 0 0 15px rgba(255, 193, 7, 0.7);
                transform: scale(1.1);
            }
        }
        
        .sequence-card.current.hidden {
            /* 初始化时隐藏高亮框 */
            background-color: transparent;
            border: 3px solid transparent;
            box-shadow: none;
            transform: scale(1);
        }
        
        .sequence-card.empty-card {
            /* 空白卡片样式 */
            background-color: transparent;
            border: 1px dashed #ccc;
            color: transparent;
        }
        
        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 14px;
        }
        
        /* 扑克牌编码映射（位置记忆法） */
        .grid-container {
            display: grid;
            /* 明确设置15列的结构，不会重组 */
            grid-template-columns: repeat(15, var(--card-width));
            /* 明确设置4行的结构 */
            grid-template-rows: repeat(4, var(--card-height));
            /* 设置列间距和行间距 */
            column-gap: var(--column-gap);
            row-gap: var(--row-gap);
            /* 居中显示 */
            margin: 0 auto;
            margin-bottom: 20px;
            /* 确保宽度适合内容，不会重组 */
            width: fit-content;
            /* 最小宽度为内容宽度，确保不会重组 */
            min-width: min-content;
            /* 隐藏滚动条 */
            overflow: hidden;
        }
        
        /* 确保容器不会限制grid布局的宽度 */
        .container {
            /* 最大宽度为100% */
            max-width: 100%;
            /* 隐藏滚动条 */
            overflow: hidden;
        }
        
        /* 确保body不会限制容器宽度 */
        body {
            /* 隐藏滚动条 */
            overflow: hidden;
        }
        
        /* 网格项样式 */
        .grid-item {
            background-color: #f5f5f5;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            padding: var(--card-padding);
            text-align: center;
            font-weight: bold;
            color: #1976d2;
            height: var(--card-height);
            width: var(--card-width); /* 使用 --card-width 变量，确保卡片宽度和高度可以不同 */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease;
            cursor: pointer;
            box-sizing: border-box; /* 确保padding和border不影响卡片尺寸 */
        }
        

        
        .grid-item:hover {
            background-color: #e0e0e0;
        }
        
        /* 特殊位置的格子 */
        .top-item {
            background-color: #f5f5f5;
            border: 1px solid #ffcc80;
            color: #ef6c00;
        }
        
        .top-item:hover {
            background-color: #e0e0e0;
        }
        
        /* 2的卡片样式 */
        .two-item {
            background-color: #f5f5f5;
            border: 1px solid #e1bee7;
            color: #7b1fa2;
        }
        
        .two-item:hover {
            background-color: #e0e0e0;
        }
        
        /* 激活状态 */
        .active {
            background-color: #4caf50 !important;
            color: white !important;
        }
        
        /* 空白卡片样式 */
        .empty-card {
            background-color: #f5f5f5 !important;
            border: 1px solid #ffcc80 !important;
            cursor: default !important;
            color: transparent !important;
        }
        
        .empty-card:hover {
            background-color: #e0e0e0 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>记忆训练</h1>
        
        <!-- 功能按钮 -->
        <div class="control-buttons">
            <button onclick="startSingleGame()" id="singleGameButton">单次训练</button>
            <button onclick="startLoopGame()" id="loopGameButton">循环训练</button>
            <div class="speed-control">
                <label for="speedSlider">速度: <span id="speedValue">1.0x</span></label>
                <input type="range" id="speedSlider" min="0.5" max="10.0" step="0.1" value="1.0" oninput="updateSpeed(this.value)">
            </div>
        </div>
        
        <!-- 游戏模式界面 -->
        <div class="game-mode" id="gameMode">
            <!-- 移除游戏模式标题 -->
            
            <!-- 上部卡片序列窗口 -->
            <div class="card-sequence-container">
                <div class="card-sequence" id="cardSequence">
                    <!-- 卡片序列将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <!-- 游戏状态统计信息（已隐藏） -->
            <div class="game-stats" style="display: none;">
                <div>当前进度: <span id="gameProgress">0/54</span></div>
                <div>正确次数: <span id="gameCorrect">0</span></div>
                <div>错误次数: <span id="gameWrong">0</span></div>
                <div>当前速度: <span id="gameSpeed">1.0x</span></div>
            </div>
        </div>
        
        <!-- 扑克牌编码映射（位置记忆法） -->
        <div class="grid-container">
            <!-- 第一行：3-5, 6-8, 9-10, J-Q-K-A, 2, 空白, 空白 -->
            <div class="grid-item" onclick="toggleStatus(this)">3</div>
            <div class="grid-item" onclick="toggleStatus(this)">4</div>
            <div class="grid-item" onclick="toggleStatus(this)">5</div>
            <div class="grid-item" onclick="toggleStatus(this)">6</div>
            <div class="grid-item" onclick="toggleStatus(this)">7</div>
            <div class="grid-item" onclick="toggleStatus(this)">8</div>
            <div class="grid-item" onclick="toggleStatus(this)">9</div>
            <div class="grid-item" onclick="toggleStatus(this)">10</div>
            <div class="grid-item" onclick="toggleStatus(this)">J</div>
            <div class="grid-item" onclick="toggleStatus(this)">Q</div>
            <div class="grid-item" onclick="toggleStatus(this)">K</div>
            <div class="grid-item" onclick="toggleStatus(this)">A</div>
            <div class="grid-item two-item" onclick="toggleStatus(this)">2</div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            
            <!-- 第二行：3-5, 6-8, 9-10, J-Q-K-A, 2, 空白, 空白 -->
            <div class="grid-item" onclick="toggleStatus(this)">3</div>
            <div class="grid-item" onclick="toggleStatus(this)">4</div>
            <div class="grid-item" onclick="toggleStatus(this)">5</div>
            <div class="grid-item" onclick="toggleStatus(this)">6</div>
            <div class="grid-item" onclick="toggleStatus(this)">7</div>
            <div class="grid-item" onclick="toggleStatus(this)">8</div>
            <div class="grid-item" onclick="toggleStatus(this)">9</div>
            <div class="grid-item" onclick="toggleStatus(this)">10</div>
            <div class="grid-item" onclick="toggleStatus(this)">J</div>
            <div class="grid-item" onclick="toggleStatus(this)">Q</div>
            <div class="grid-item" onclick="toggleStatus(this)">K</div>
            <div class="grid-item" onclick="toggleStatus(this)">A</div>
            <div class="grid-item two-item" onclick="toggleStatus(this)">2</div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            
            <!-- 第三行：3-5, 6-8, 9-10, J-Q-K-A, 2, 空白, 空白 -->
            <div class="grid-item" onclick="toggleStatus(this)">3</div>
            <div class="grid-item" onclick="toggleStatus(this)">4</div>
            <div class="grid-item" onclick="toggleStatus(this)">5</div>
            <div class="grid-item" onclick="toggleStatus(this)">6</div>
            <div class="grid-item" onclick="toggleStatus(this)">7</div>
            <div class="grid-item" onclick="toggleStatus(this)">8</div>
            <div class="grid-item" onclick="toggleStatus(this)">9</div>
            <div class="grid-item" onclick="toggleStatus(this)">10</div>
            <div class="grid-item" onclick="toggleStatus(this)">J</div>
            <div class="grid-item" onclick="toggleStatus(this)">Q</div>
            <div class="grid-item" onclick="toggleStatus(this)">K</div>
            <div class="grid-item" onclick="toggleStatus(this)">A</div>
            <div class="grid-item two-item" onclick="toggleStatus(this)">2</div>
            <div class="grid-item empty-card"></div>
            <div class="grid-item empty-card"></div>
            
            <!-- 第四行：3-5, 6-8, 9-10, J-Q-K-A, 2, 小, 大 -->
            <div class="grid-item" onclick="toggleStatus(this)">3</div>
            <div class="grid-item" onclick="toggleStatus(this)">4</div>
            <div class="grid-item" onclick="toggleStatus(this)">5</div>
            <div class="grid-item" onclick="toggleStatus(this)">6</div>
            <div class="grid-item" onclick="toggleStatus(this)">7</div>
            <div class="grid-item" onclick="toggleStatus(this)">8</div>
            <div class="grid-item" onclick="toggleStatus(this)">9</div>
            <div class="grid-item" onclick="toggleStatus(this)">10</div>
            <div class="grid-item" onclick="toggleStatus(this)">J</div>
            <div class="grid-item" onclick="toggleStatus(this)">Q</div>
            <div class="grid-item" onclick="toggleStatus(this)">K</div>
            <div class="grid-item" onclick="toggleStatus(this)">A</div>
            <div class="grid-item two-item" onclick="toggleStatus(this)">2</div>
            <div class="grid-item top-item" onclick="toggleStatus(this)">小</div>
            <div class="grid-item top-item" onclick="toggleStatus(this)">大</div>
        </div>
        
        <!-- 训练消息提示（放在卡牌网格下方） -->
        <div class="game-message" id="gameMessage">
            <h4>本次训练</h4>
            <p id="messageText">
                <span id="timeDisplay">用时: 0.00秒</span><br>
                <span id="speedDisplay">速度: 0.00卡/秒</span>
            </p>
        </div>
    </div>
    
    <script>
        // 游戏状态
        let gameMode = true; // 默认启用游戏模式
        let autoMode = false; // 自动执行模式
        let isLoopMode = false; // 循环训练模式
        let gameState = {
            isPlaying: false,
            currentIndex: 0,
            shuffledCards: [],
            correctCount: 0,
            wrongCount: 0,
            speed: 1.0,
            baseSpeed: 1.0,
            acceleration: 0.01,
            scrollPosition: 0,
            scrollSpeed: 2,
            gameTimer: null,
            startTime: 0,
            isFirstCorrect: true,
            lastClickedIndex: -1
        };
        
        // 观察器实例
        let observer;
        
        // 卡片映射数组
        const cardMap = [];
        
        // 初始化卡片映射
        function initCardMap() {
            // 花色顺序：黑桃、红桃、梅花、方片
            const suits = ['♠', '♥', '♣', '♦'];
            // 牌值顺序：3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A, 2
            const values = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
            
            // 生成所有牌的映射
            let index = 1;
            for (const value of values) {
                for (const suit of suits) {
                    cardMap.push({ value: value, suit: suit, display: suit + ' ' + value, order: index });
                    index++;
                }
            }
            
            // 添加小王和大王
            cardMap.push({ value: '小', suit: '', display: '小', order: 53 });
            cardMap.push({ value: '大', suit: '', display: '大', order: 54 });
        }
        
        // 初始化Intersection Observer
        function initObserver() {
            // 配置观察器
            const options = {
                root: document.getElementById('cardSequence'), // 滚动容器
                rootMargin: '0px', // 边距
                threshold: 0.3 // 当元素30%不在视口中时触发
            };
            
            // 创建观察器
            observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    // 当高亮卡片不在视口中，且游戏正在进行时，触发游戏失败
                    if (!entry.isIntersecting && gameState.isPlaying) {
                        gameOver(false);
                    }
                });
            }, options);
        }
        
        // 初始化游戏模式
        function initGameMode() {
            // 显示训练消息框
            document.getElementById('gameMessage').style.display = 'block';
            
            // 清除所有卡片的激活状态
            clearAllCards();
            
            // 保存当前速度设置
            const currentSpeed = gameState.speed || 1.0;
            
            // 重置游戏状态
            gameState = {
                isPlaying: false,
                currentIndex: 0,
                shuffledCards: [],
                correctCount: 0,
                wrongCount: 0,
                speed: currentSpeed, // 保留当前速度设置
                baseSpeed: currentSpeed, // 保留当前速度设置
                acceleration: 0.01,
                gameTimer: null,
                startTime: 0,
                isFirstCorrect: true,
                lastClickedIndex: -1
            };
            
            // 生成随机排列（Fisher-Yates洗牌算法）
            gameState.shuffledCards = [...cardMap].sort(() => Math.random() - 0.5);
            
            // 生成卡片序列
            generateCardSequence();
            
            // 更新游戏界面
            updateGameUI();
            
            // 更新卡片序列，显示当前卡片
            updateCardSequence();
            
            // 初始时，更新卡片序列，显示初始状态
            const sequenceCards = document.querySelectorAll('.sequence-card');
            if (sequenceCards.length > 0) {
                // 初始更新卡片内容
                updateCardSequence();
            }
        }
        
        // 重新开始游戏
        function restartGame() {
            initGameMode();
            
            // 重置按钮状态
            const button = document.getElementById('startButton');
            button.textContent = '开始训练';
            button.disabled = false;
            button.style.backgroundColor = '#4CAF50';
            button.onclick = startGame;
        }
        
        // 生成卡片序列（固定格子模式）
        function generateCardSequence() {
            const sequenceContainer = document.getElementById('cardSequence');
            sequenceContainer.innerHTML = '';
            
            // 确保有54张卡片
            if (gameState.shuffledCards.length !== 54) {
                // 重新生成54张卡片
                initCardMap();
                gameState.shuffledCards = [...cardMap].sort(() => Math.random() - 0.5);
            }
            
            // 直接使用15个格子，对应下边的15列
            const maxCards = 15;
            
            // 生成卡片格子
            for (let i = 0; i < maxCards; i++) {
                const sequenceCard = document.createElement('div');
                sequenceCard.className = 'sequence-card';
                sequenceCard.textContent = '';
                sequenceCard.dataset.index = i;
                sequenceCard.dataset.value = '';
                sequenceContainer.appendChild(sequenceCard);
            }
        }
        
        // 更新卡片序列（固定格子模式）
        function updateCardSequence() {
            const sequenceCards = document.querySelectorAll('.sequence-card');
            
            // 计算中间位置
            const centerIndex = Math.floor(sequenceCards.length / 2);
            
            // 移除所有卡片的高亮状态
            sequenceCards.forEach(card => {
                card.classList.remove('current');
            });
            
            // 更新卡片内容
            sequenceCards.forEach((card, cardIndex) => {
                // 计算要显示的卡片索引，中间卡片显示当前索引-1（整体向后移动一个格子）
                const displayIndex = gameState.currentIndex + (cardIndex - centerIndex) - 1;
                
                if (displayIndex >= 0 && displayIndex < gameState.shuffledCards.length) {
                    // 显示有效卡片
                    const displayCard = gameState.shuffledCards[displayIndex];
                    card.textContent = displayCard.display;
                    card.dataset.value = displayCard.value;
                    
                    // 标记已完成的卡片，但中间卡片除外
                    if (displayIndex < gameState.currentIndex && cardIndex !== centerIndex) {
                        card.classList.add('completed');
                    } else {
                        card.classList.remove('completed');
                    }
                } else {
                    // 显示空白卡片
                    card.textContent = '';
                    card.dataset.value = '';
                    card.classList.remove('completed');
                }
            });
            
            // 在中间格子添加高亮状态
            const centerCard = sequenceCards[centerIndex];
            if (centerCard) {
                centerCard.classList.add('current');
                // 移除闪动效果，保持始终高亮
            }
        }
        
        // 高亮上部对应卡片（已移除高亮功能，仅保留函数结构）
        function highlightSequenceCard(cardValue, index) {
            // 已移除高亮功能，滚动逻辑由updateCardSequence函数处理
        }
        
        // 游戏主循环
        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            // 确保游戏速度与当前设置一致
            document.getElementById('gameSpeed').textContent = gameState.speed.toFixed(1) + 'x';
            
            // 继续游戏循环
            gameState.gameTimer = requestAnimationFrame(gameLoop);
        }
        
        // 自动点击控制函数
        function startAutoClick() {
            if (!gameState.isPlaying) return;
            
            // 自动点击当前需要的卡片
            if (autoMode && gameState.isPlaying) {
                autoClickCurrentCard();
            }
            
            // 按照配置的点击延迟时间重复执行，并根据当前速度调整延迟
            if (gameState.isPlaying) {
                // 速度越快，延迟越短
                let adjustedDelay = gameConfig.clickDelay / gameState.speed;
                // 添加最小延迟时间限制，避免浏览器性能问题
                const minDelay = 50; // 最小延迟时间为50毫秒
                adjustedDelay = Math.max(adjustedDelay, minDelay);
                console.log(`当前速度: ${gameState.speed}x, 调整后的延迟: ${adjustedDelay}ms`);
                setTimeout(startAutoClick, adjustedDelay);
            }
        }
        
        // 自动模式切换
        function toggleAutoMode() {
            autoMode = !autoMode;
            const button = document.getElementById('autoModeButton');
            
            if (autoMode) {
                button.textContent = '关闭自动';
                button.style.backgroundColor = '#f44336';
                // 无论游戏是否正在进行，都开始自动点击和滚动
                startAutoGame();
            } else {
                button.textContent = '自动模式';
                button.style.backgroundColor = '#4CAF50';
                // 停止自动游戏
                gameState.isPlaying = false;
                if (gameState.gameTimer) {
                    cancelAnimationFrame(gameState.gameTimer);
                    gameState.gameTimer = null;
                }
            }
        }
        
        // 开始自动游戏
        function startAutoGame() {
            gameState.isFirstCorrect = false;
            gameState.isPlaying = true;
            gameState.startTime = Date.now();
            // 开始游戏循环
            gameState.gameTimer = requestAnimationFrame(gameLoop);
            // 开始自动点击
            startAutoClick();
        }
        
        // 配置参数 - 可调整以下参数来控制游戏速度和点击速度
        const gameConfig = {
            // 滚动速度参数
            scrollSpeed: 1.0, // 滚动速度倍率
            baseSpeed: 1.0, // 初始速度倍率
            
            // 点击速度参数
            clickDelay: 1200, // 调整点击延迟时间，确保与滚动速度匹配
            
            // 点击触发条件参数
            clickThreshold: 0.8 // 大幅增加点击触发阈值，确保卡片几乎完全进入中心时才触发
        };
        
        // 更新游戏状态使用配置参数
        function updateGameConfig() {
            gameState.scrollSpeed = gameConfig.scrollSpeed;
            gameState.baseSpeed = gameConfig.baseSpeed;
        }
        
        // 自动点击当前需要的卡片
        function autoClickCurrentCard() {
            if (gameState.currentIndex >= gameState.shuffledCards.length) return;
            
            // 检查当前索引是否已经被处理过
            if (gameState.lastClickedIndex === gameState.currentIndex) return;
            
            // 标记当前索引已处理，避免重复点击
            gameState.lastClickedIndex = gameState.currentIndex;
            
            // 获取当前需要点击的卡片
            const currentCard = gameState.shuffledCards[gameState.currentIndex];
            if (!currentCard) return;
            
            // 找到对应的卡片元素
            const allCards = document.querySelectorAll('.grid-container > div');
            let targetCard = null;
            
            // 无花色模式：根据卡片类型选择正确的卡片
            if (currentCard.value === '小' || currentCard.value === '大') {
                // 大小王：选择最底部未激活的
                const kingCards = [];
                allCards.forEach(card => {
                    if (card.textContent === currentCard.display) {
                        kingCards.push(card);
                    }
                });
                // 从底部向上查找未激活的卡片
                for (let i = kingCards.length - 1; i >= 0; i--) {
                    if (!kingCards[i].classList.contains('active')) {
                        targetCard = kingCards[i];
                        break;
                    }
                }
            } else if (currentCard.value === '2') {
                // 2的卡片：选择最底部未激活的
                const twoCards = [];
                allCards.forEach(card => {
                    if (card.textContent.includes('2')) {
                        twoCards.push(card);
                    }
                });
                // 从底部向上查找未激活的卡片
                for (let i = twoCards.length - 1; i >= 0; i--) {
                    if (!twoCards[i].classList.contains('active')) {
                        targetCard = twoCards[i];
                        break;
                    }
                }
            } else {
                // 其他卡片：选择最底部未激活的
                const valueCards = [];
                allCards.forEach(card => {
                    if (card.textContent.includes(currentCard.value)) {
                        valueCards.push(card);
                    }
                });
                // 从底部向上查找未激活的卡片
                for (let i = valueCards.length - 1; i >= 0; i--) {
                    if (!valueCards[i].classList.contains('active')) {
                        targetCard = valueCards[i];
                        break;
                    }
                }
            }
            
            // 如果找到目标卡片，触发点击
            if (targetCard) {
                // 保存当前索引，确保高亮和点击使用相同的索引
                const currentIndex = gameState.currentIndex;
                
                // 使用根据当前速度调整后的延迟时间
                let adjustedDelay = gameConfig.clickDelay / gameState.speed;
                // 添加最小延迟时间限制，避免浏览器性能问题
                const minDelay = 50; // 最小延迟时间为50毫秒
                adjustedDelay = Math.max(adjustedDelay, minDelay);
                
                setTimeout(() => {
                    // 1. 点击下方对应的卡片，使其背景变为绿色
                    targetCard.classList.add('active');
                    
                    // 2. 增加正确次数
                    gameState.correctCount++;
                    
                    // 3. 增加当前索引
                    gameState.currentIndex++;
                    
                    // 4. 更新游戏界面
                    updateGameUI();
                    
                    // 5. 更新卡片序列（这会自动处理高亮框的移动）
                    updateCardSequence();
                    
                    // 6. 重置lastClickedIndex，以便下一张卡片可以被正确处理
                    gameState.lastClickedIndex = -1;
                    
                    // 7. 检查游戏是否结束
                    if (gameState.currentIndex >= 54) {
                        // 训练完成
                        gameOver(true);
                    }
                    
                }, adjustedDelay); // 使用调整后的延迟时间
            } else {
                // 如果没有找到目标卡片，重置lastClickedIndex，继续尝试
                gameState.lastClickedIndex = -1;
            }
        }
        
        // 结束游戏
        function endGame() {
            gameState.isPlaying = false;
            
            // 清除游戏定时器
            if (gameState.gameTimer) {
                cancelAnimationFrame(gameState.gameTimer);
                gameState.gameTimer = null;
            }
            
            clearAllCards();
        }

        // 训练结束处理
        function gameOver(isWin) {
            gameState.isPlaying = false;
            
            // 清除游戏定时器
            if (gameState.gameTimer) {
                cancelAnimationFrame(gameState.gameTimer);
                gameState.gameTimer = null;
            }
            
            // 显示训练结果
            const timeDisplay = document.getElementById('timeDisplay');
            const speedDisplay = document.getElementById('speedDisplay');
            
            if (isWin) {
                const endTime = Date.now();
                const duration = (endTime - gameState.startTime) / 1000;
                const speed = (gameState.correctCount / duration).toFixed(2);
                timeDisplay.textContent = `用时: ${duration.toFixed(2)}秒`;
                speedDisplay.textContent = `速度: ${speed}卡/秒`;
                
                // 如果是循环训练模式，自动重新开始游戏
                if (isLoopMode) {
                    setTimeout(() => {
                        startLoopGame();
                    }, 1000); // 1秒后自动重新开始
                } else {
                    // 重置按钮状态
                    const singleButton = document.getElementById('singleGameButton');
                    const loopButton = document.getElementById('loopGameButton');
                    singleButton.textContent = '单次训练';
                    singleButton.disabled = false;
                    singleButton.style.backgroundColor = '#4CAF50';
                    singleButton.onclick = startSingleGame;
                    loopButton.textContent = '循环训练';
                    loopButton.disabled = false;
                    loopButton.style.backgroundColor = '#4CAF50';
                    loopButton.onclick = startLoopGame;
                }
            } else {
                timeDisplay.textContent = '训练失败！';
                speedDisplay.textContent = '';
                
                // 重置按钮状态
                const singleButton = document.getElementById('singleGameButton');
                const loopButton = document.getElementById('loopGameButton');
                singleButton.textContent = '单次训练';
                singleButton.disabled = false;
                singleButton.style.backgroundColor = '#4CAF50';
                singleButton.onclick = startSingleGame;
                loopButton.textContent = '循环训练';
                loopButton.disabled = false;
                loopButton.style.backgroundColor = '#4CAF50';
                loopButton.onclick = startLoopGame;
            }
        }
        
        // 更新游戏界面
        function updateGameUI() {
            document.getElementById('gameProgress').textContent = `${gameState.currentIndex}/54`;
            document.getElementById('gameCorrect').textContent = gameState.correctCount;
            document.getElementById('gameWrong').textContent = gameState.wrongCount;
            
            // 更新训练消息框中的信息
            const timeDisplay = document.getElementById('timeDisplay');
            const speedDisplay = document.getElementById('speedDisplay');
            
            if (gameState.isPlaying && gameState.startTime > 0) {
                const currentTime = Date.now();
                const duration = (currentTime - gameState.startTime) / 1000;
                const speed = gameState.correctCount > 0 ? (gameState.correctCount / duration).toFixed(2) : '0.00';
                timeDisplay.textContent = `用时: ${duration.toFixed(2)}秒`;
                speedDisplay.textContent = `速度: ${speed}卡/秒`;
            } else if (gameState.correctCount > 0) {
                // 训练结束后显示最终结果
                const endTime = Date.now();
                const duration = (endTime - gameState.startTime) / 1000;
                const speed = (gameState.correctCount / duration).toFixed(2);
                timeDisplay.textContent = `用时: ${duration.toFixed(2)}秒`;
                speedDisplay.textContent = `速度: ${speed}卡/秒`;
            } else {
                // 初始状态
                timeDisplay.textContent = '用时: 0.00秒';
                speedDisplay.textContent = '速度: 0.00卡/秒';
            }
        }
        
        // 显示下一张卡片
        function showNextCard() {
            if (gameState.currentIndex >= 54) {
                // 游戏胜利
                gameOver(true);
                return;
            }
            
            // 更新游戏界面
            updateGameUI();
            
            // 重置lastClickedIndex，以便下一张卡片可以被正确处理
            gameState.lastClickedIndex = -1;
            
            // 更新卡片序列
            updateCardSequence();
            
            // 停止观察之前的卡片
            if (observer) {
                observer.disconnect();
            }
            
            // 开始观察当前高亮卡片
            const currentCard = document.querySelector('.sequence-card.current');
            if (currentCard && observer) {
                observer.observe(currentCard);
            }
        }
        
        // 检查用户点击的卡片是否正确
        function checkCardClick(cardElement) {
            if (!gameMode) return;
            
            const clickedCardText = cardElement.textContent;
            const currentCard = gameState.shuffledCards[gameState.currentIndex];
            
            // 检查是否正确：
            // 1. 对于大小王，必须完全匹配
            // 2. 对于其他卡片，只需要匹配数字部分
            let isCorrect = false;
            
            if (currentCard.value === '小' || currentCard.value === '大') {
                // 大小王必须完全匹配
                isCorrect = (clickedCardText === currentCard.display);
            } else {
                // 其他卡片只需要匹配数字部分
                // 提取点击卡片的数字部分
                const clickedValue = clickedCardText.replace(/[^0-9JQKA]/g, '').trim();
                // 提取当前卡片的数字部分
                const currentValue = currentCard.value;
                isCorrect = (clickedValue === currentValue);
            }
            
            if (isCorrect) {
                // 正确
                // 始终使用无花色模式的逻辑
                // 找到所有卡片并分组
                const allCards = document.querySelectorAll('.grid-container > div');
                
                // 分组映射：3-10, J-Q-K-A, 2, 小, 大
                const groups = {
                    '3': [],
                    '4': [],
                    '5': [],
                    '6': [],
                    '7': [],
                    '8': [],
                    '9': [],
                    '10': [],
                    'J': [],
                    'Q': [],
                    'K': [],
                    'A': [],
                    '2': [],
                    '小': [],
                    '大': []
                };
                
                // 收集卡片到对应分组
                allCards.forEach(card => {
                    const text = card.textContent;
                    if (text.includes('3') && card.hasAttribute('onclick')) groups['3'].push(card);
                    else if (text.includes('4') && card.hasAttribute('onclick')) groups['4'].push(card);
                    else if (text.includes('5') && card.hasAttribute('onclick')) groups['5'].push(card);
                    else if (text.includes('6') && card.hasAttribute('onclick')) groups['6'].push(card);
                    else if (text.includes('7') && card.hasAttribute('onclick')) groups['7'].push(card);
                    else if (text.includes('8') && card.hasAttribute('onclick')) groups['8'].push(card);
                    else if (text.includes('9') && card.hasAttribute('onclick')) groups['9'].push(card);
                    else if (text.includes('10') && card.hasAttribute('onclick')) groups['10'].push(card);
                    else if (text.includes('J') && card.hasAttribute('onclick')) groups['J'].push(card);
                    else if (text.includes('Q') && card.hasAttribute('onclick')) groups['Q'].push(card);
                    else if (text.includes('K') && card.hasAttribute('onclick')) groups['K'].push(card);
                    else if (text.includes('A') && card.hasAttribute('onclick')) groups['A'].push(card);
                    else if (text.includes('2') && card.hasAttribute('onclick')) groups['2'].push(card);
                    else if (text.includes('小') && card.hasAttribute('onclick')) groups['小'].push(card);
                    else if (text.includes('大') && card.hasAttribute('onclick')) groups['大'].push(card);
                });
                
                // 根据当前卡片的值选择对应的分组进行处理
                if (currentCard.value === '2') {
                    // 对于2的卡片：从底部向上排列
                    const twoGroup = groups['2'];
                    if (twoGroup.length > 0) {
                        // 找到第一个从底部开始未激活的卡片
                        for (let i = twoGroup.length - 1; i >= 0; i--) {
                            if (!twoGroup[i].classList.contains('active')) {
                                twoGroup[i].classList.add('active');
                                break;
                            }
                        }
                    }
                } else if (currentCard.value === '小' || currentCard.value === '大') {
                    // 对于大小王：从底部向上排列
                    const kingGroup = groups[currentCard.value];
                    if (kingGroup.length > 0) {
                        // 找到第一个从底部开始未激活的卡片
                        for (let i = kingGroup.length - 1; i >= 0; i--) {
                            if (!kingGroup[i].classList.contains('active')) {
                                kingGroup[i].classList.add('active');
                                break;
                            }
                        }
                    }
                } else {
                    // 对于数字和字母卡片：从底部向上渲染
                    const group = groups[currentCard.value];
                    if (group.length > 0) {
                        // 找到第一个从底部开始未激活的卡片
                        for (let i = group.length - 1; i >= 0; i--) {
                            if (!group[i].classList.contains('active')) {
                                group[i].classList.add('active');
                                break;
                            }
                        }
                    }
                }
                
                // 增加正确次数
                gameState.correctCount++;
                
                // 增加当前索引
                gameState.currentIndex++;
                
                // 添加延迟，确保滚动有足够时间完成
                setTimeout(() => {
                    // 更新卡片序列（这会自动处理高亮框的移动）
                    updateCardSequence();
                    // 显示下一张卡片
                    showNextCard();
                }, 200); // 200毫秒延迟，给滚动足够时间调整
                
            } else {
                // 错误
                gameState.wrongCount++;
                
                // 显示错误消息
                const timeDisplay = document.getElementById('timeDisplay');
                const speedDisplay = document.getElementById('speedDisplay');
                timeDisplay.textContent = '错误！请重新开始。';
                speedDisplay.textContent = '';
                
                // 游戏结束
                gameState.isPlaying = false;
                if (gameState.gameTimer) {
                    cancelAnimationFrame(gameState.gameTimer);
                    gameState.gameTimer = null;
                }
            }
        }
        
        // 清除所有卡片的状态
        function clearAllCards() {
            const cards = document.querySelectorAll('.grid-container > div');
            cards.forEach(card => {
                card.classList.remove('active');
            });
        }
        
        // 修改toggleStatus函数，添加游戏模式的卡片点击检查
        function toggleStatus(element) {
            if (gameMode) {
                // 在游戏模式下，无论isPlaying是否为true，都调用checkCardClick函数
                checkCardClick(element);
            } else {
                if (element.classList.contains('active')) {
                    element.classList.remove('active');
                } else {
                    element.classList.add('active');
                }
            }
        }
        

        
        // 开始单次训练函数
        function startSingleGame() {
            // 初始化游戏模式
            initGameMode();
            
            // 禁用循环模式
            isLoopMode = false;
            
            // 启用自动模式
            autoMode = true;
            
            // 更新按钮状态
            const singleButton = document.getElementById('singleGameButton');
            const loopButton = document.getElementById('loopGameButton');
            singleButton.textContent = '暂停';
            singleButton.disabled = false;
            singleButton.style.backgroundColor = '#ff9800';
            singleButton.onclick = pauseGame;
            loopButton.disabled = true;
            
            // 开始自动游戏
            startAutoGame();
        }
        
        // 开始循环训练函数
        function startLoopGame() {
            // 初始化游戏模式
            initGameMode();
            
            // 启用循环模式
            isLoopMode = true;
            
            // 启用自动模式
            autoMode = true;
            
            // 更新按钮状态
            const singleButton = document.getElementById('singleGameButton');
            const loopButton = document.getElementById('loopGameButton');
            loopButton.textContent = '暂停';
            loopButton.disabled = false;
            loopButton.style.backgroundColor = '#ff9800';
            loopButton.onclick = pauseGame;
            singleButton.disabled = true;
            
            // 开始自动游戏
            startAutoGame();
        }
        
        // 暂停游戏函数
        function pauseGame() {
            // 暂停自动模式
            autoMode = false;
            gameState.isPlaying = false;
            
            // 清除游戏定时器
            if (gameState.gameTimer) {
                cancelAnimationFrame(gameState.gameTimer);
                gameState.gameTimer = null;
            }
            
            // 更新按钮状态
            const singleButton = document.getElementById('singleGameButton');
            const loopButton = document.getElementById('loopGameButton');
            
            if (isLoopMode) {
                loopButton.textContent = '继续';
                loopButton.style.backgroundColor = '#4CAF50';
                loopButton.onclick = resumeGame;
            } else {
                singleButton.textContent = '继续';
                singleButton.style.backgroundColor = '#4CAF50';
                singleButton.onclick = resumeGame;
            }
        }
        
        // 继续游戏函数
        function resumeGame() {
            // 恢复自动模式
            autoMode = true;
            gameState.isPlaying = true;
            
            // 更新按钮状态
            const singleButton = document.getElementById('singleGameButton');
            const loopButton = document.getElementById('loopGameButton');
            
            if (isLoopMode) {
                loopButton.textContent = '暂停';
                loopButton.style.backgroundColor = '#ff9800';
                loopButton.onclick = pauseGame;
            } else {
                singleButton.textContent = '暂停';
                singleButton.style.backgroundColor = '#ff9800';
                singleButton.onclick = pauseGame;
            }
            
            // 重新开始游戏循环
            gameState.gameTimer = requestAnimationFrame(gameLoop);
            // 重新开始自动点击
            startAutoClick();
        }
        
        // 更新速度函数
        function updateSpeed(value) {
            const speedValue = parseFloat(value);
            gameState.baseSpeed = speedValue;
            gameState.speed = speedValue;
            document.getElementById('speedValue').textContent = speedValue.toFixed(1) + 'x';
            document.getElementById('gameSpeed').textContent = speedValue.toFixed(1) + 'x';
            console.log(`速度已更新为: ${speedValue}x`);
        }
        
        // 初始化函数
        function init() {
            // 初始化卡片映射
            initCardMap();
            
            // 初始化游戏模式
            initGameMode();
            
            // 初始化游戏配置
            updateGameConfig();
            
            // 初始化速度控制
            updateSpeed(1.0);
            
            // 添加窗口大小变化事件监听器
            window.addEventListener('resize', function() {
                // 重新生成卡片序列，根据新的窗口大小调整格子数量
                generateCardSequence();
                updateCardSequence();
            });
        }
        
        // 页面加载完成后初始化
        window.onload = init;
    </script>
</body>
</html>